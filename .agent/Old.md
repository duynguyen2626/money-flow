//code.gs
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('üìä Monthly Tools')
    .addItem('T·∫°o Sheet Th√°ng M·ªõi', 'createMonthlySheetFull')
    .addToUi();
}

function createMonthlySheetFull() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const today = new Date();
  const year = today.getFullYear();
  const month = today.getMonth();
  const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
  const sheetName = `${monthNames[month]}.${year.toString().slice(-2)}`;
  const tagUpper = `${monthNames[month]}${year.toString().slice(-2)}`;

  // X√≥a sheet c≈© n·∫øu ƒë√£ c√≥
  const oldSheet = ss.getSheetByName(sheetName);
  if (oldSheet) ss.deleteSheet(oldSheet);
  const sheet = ss.insertSheet(sheetName);

  // Header A1:I1
  const headers = ['Type','Date','Shop','Notes','Amount','% Back','ƒë Back','Œ£ Back','Final Price'];
  sheet.getRange('A1:I1')
    .setValues([headers])
    .setFontWeight('bold')
    .setBackground('#f3f3f3')
    .setFontSize(12)
    .setBorder(true,true,true,true,true,true);

  // Formula H2 / I2
  sheet.getRange('H2').setFormula('=ARRAYFORMULA(IF(E2:E="","",IF(E2:E*F2:F/100+G2:G=0,"",E2:E*F2:F/100+G2:G)))');
  sheet.getRange('I2').setFormula('=ARRAYFORMULA(IF(E2:E="","",IF(A2:A="In",(E2:E-H2:H)*(-1),E2:E-H2:H)))');

  // Format c√°c c·ªôt
  sheet.getRange('B2:B').setNumberFormat('dd-MM');
  ['E','G','H','I'].forEach(c => sheet.getRange(c+'2:'+c).setNumberFormat('#,##0'));
  sheet.setColumnWidth(1,70);
  sheet.setColumnWidth(2,100);
  sheet.setColumnWidth(3,50);
  sheet.setColumnWidth(4,400);
  sheet.setColumnWidth(10,20);
  sheet.autoResizeColumn(9); // Auto-fit Final Price
  sheet.getRange('A:A').setHorizontalAlignment('left');
  sheet.getRange('B:B').setHorizontalAlignment('left');
  sheet.getRange('C:C').setHorizontalAlignment('center').setFontSize(7);
  sheet.getRange('J:J').setBackground('#d9c37b');
  sheet.getRange('A1:I100').setFontSize(12).setBorder(true,true,true,true,true,true);

  // --- B·∫£ng t·ªïng ---
  sheet.getRange('K1:L1')
    .setValues([['Summary','Value']])
    .setFontWeight('bold')
    .setBackground('#fde4e4')
    .setFontSize(15)
    .setHorizontalAlignment('center')
    .setBorder(true,true,true,true,true,true);

  sheet.getRange('K2:K5').setValues([
    ['In'],
    ['Out'],
    ['Sum Back'],
    [`Debt ${tagUpper}`]
  ]);

  sheet.getRange('L2').setFormula('=SUMIFS(I:I,A:A,"In")');
  sheet.getRange('L3').setFormula('=SUMIFS(I:I,A:A,"Out")');
  sheet.getRange('L4').setFormula('=SUM(H2:H)');
  sheet.getRange('L5').setFormula('=L2+L3');

  sheet.getRange('K2:L5').setFontSize(12).setBorder(true,true,true,true,true,true);
  sheet.getRange('L2:L5').setNumberFormat('#,##0');
  sheet.getRange('K2:L5').setHorizontalAlignment('left');

  // ƒê·ªãnh d·∫°ng ri√™ng L5: In ƒë·∫≠m, ƒë·ªè nh·∫°t, size l·ªõn, auto fit width
  const debtRange = sheet.getRange('L5');
  debtRange.setFontWeight('bold').setBackground('#f8d0d0').setFontSize(15);
  sheet.autoResizeColumn(12);

  // Tag th√°ng text an to√†n
  sheet.getRange('K5').setNumberFormat('@STRING@').setValue("'" + `Debt ${tagUpper}`);

  // C√¥ng th·ª©c d·ªØ li·ªáu ·ªü A2
  const filterFormula =
    '=SORT(' +
      'IFNA(' +
        'FILTER({' +
          'tbl.' + year + '[Type],' +
          'tbl.' + year + '[Date],' +
          'IFERROR(VLOOKUP(tbl.' + year + '[Shop], tbl.Shop, 2, FALSE), VLOOKUP("Bank", tbl.Shop, 2, FALSE)),' +
          'tbl.' + year + '[Notes],' +
          'tbl.' + year + '[Amount],' +
          'tbl.' + year + '[% Back],' +
          'tbl.' + year + '[ƒë Back]' +
        '}, tbl.' + year + '[Tag]="' + tagUpper + '"),' +
        'VLOOKUP("Tpbank", tbl.Shop, 2, FALSE)' +
      '),' +
      '2, TRUE' +
    ')';
  sheet.getRange('A2').setFormula(filterFormula);

  // Conditional formats:
  const rangeData = sheet.getRange('A2:I100');

  // Type="In"
  const rule1 = SpreadsheetApp.newConditionalFormatRule()
    .whenFormulaSatisfied('=$A2="In"')
    .setBackground("#D5F5E3")
    .setFontColor("#145A32")
    .setRanges([rangeData])
    .build();

  // Final Price in ƒë·∫≠m khi Type="In" ho·∫∑c gi√° tr·ªã √¢m
  const rule2 = SpreadsheetApp.newConditionalFormatRule()
    .whenFormulaSatisfied('=OR($A2="In",$I2<0)')
    .setBold(true)
    .setRanges([sheet.getRange('I2:I100')])
    .build();

  sheet.setConditionalFormatRules([rule1, rule2]);

  SpreadsheetApp.getActive().toast(
    `Sheet "${sheetName}" ƒë√£ t·∫°o ho√†n t·∫•t ‚Äì b·∫£ng t·ªïng Debt t√¥ ƒë·ªè + Final Price ƒë√£ in ƒë·∫≠m.`,
    "Monthly Sheet", 5
  );
}
//sendTosheet.gs
/**
 * MoneyFlow Sync Script
 * Generated by Antigravity
 * Date: 2025-12-03T22:30:00+07:00
 * 
 * Features:
 * - Supports Batch Sync (Array of transactions)
 * - Supports Single Sync (Single object)
 * - Upsert Logic (Update if ID exists, Insert if not)
 * - System Logging (Writes errors to _SystemLogs sheet)
 * - Lock Service (Prevents race conditions)
 */
function doPost(e) {
  var lock = LockService.getScriptLock();
  // Wait up to 30 seconds for other processes to finish.
  lock.tryLock(30000);
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var logSheet = ensureLogSheet(ss);
  try {
    // --- 1. PARSE & VALIDATE DATA ---
    if (!e || !e.postData || !e.postData.contents) {
      throw new Error("No post data received");
    }
    var rawData = JSON.parse(e.postData.contents);
    
    // Support handling both single object and array of objects (for Sync All)
    // New Format: { action: "sync_all", transactions: [...] }
    var transactions = [];
    var isSyncAll = false;
    if (Array.isArray(rawData)) {
      transactions = rawData;
    } else if (rawData.action === "sync_all" && Array.isArray(rawData.transactions)) {
      isSyncAll = true;
      transactions = rawData.transactions;
    } else {
      transactions = [rawData];
    }
    
    var output = { processed: 0, errors: [], skipped: 0 };
    // --- 1.1 HANDLE SYNC ALL (Clear Sheets) ---
    if (isSyncAll && transactions.length > 0) {
      // Identify affected years/sheets
      var affectedYears = {};
      for (var i = 0; i < transactions.length; i++) {
        var d = new Date(transactions[i].date);
        if (!isNaN(d.getTime())) {
          affectedYears[d.getFullYear().toString()] = true;
        }
      }
      
      // Clear those sheets
      for (var year in affectedYears) {
        var sheet = ss.getSheetByName(year);
        if (sheet) {
          var lastRow = sheet.getLastRow();
          if (lastRow > 1) {
            // Clear content from Row 2 to Last Row
            sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn()).clearContent();
          }
        }
      }
    }
    // --- 2. PROCESS EACH TRANSACTION ---
    for (var i = 0; i < transactions.length; i++) {
      var data = transactions[i];
      
      try {
        if (!data.id || !data.date) {
          output.skipped++;
          continue; 
        }
        // 2.1. Determine Sheet Name (Year)
        var txnDate = new Date(data.date);
        if (isNaN(txnDate.getTime())) txnDate = new Date();
        var sheetName = txnDate.getFullYear().toString();
        
        var sheet = ss.getSheetByName(sheetName);
        if (!sheet) {
          sheet = ss.insertSheet(sheetName);
          // Header Row
          sheet.appendRow(["Type", "Date", "Shop/Note", "Description", "Amount (Gross)", "% Back", "Fix Back", "Total Back", "Tag", "Transaction ID"]);
          sheet.setFrozenRows(1);
        }
        // 2.2. Format Data for Row
        var displayType = normalizeType(data.type, data.amount);
        var formattedDate = Utilities.formatDate(txnDate, "GMT+7", "dd/MM/yyyy");
        var absAmount = Math.abs(data.amount);
        
        // Row Content [Col 1 -> Col 10]
        var rowContent = [
          displayType,                // 1. Type
          formattedDate,              // 2. Date
          data.shop || "",            // 3. Shop (Account Name / Shop Name)
          data.notes || "",           // 4. Description / Note with Icon
          absAmount,                  // 5. Amount
          data.percent_back || 0,     // 6. % Back
          data.fixed_back || 0,       // 7. Fix Back
          data.total_back || 0,       // 8. Total Back
          data.tag || "",             // 9. Tag
          data.id                     // 10. Transaction ID (KEY)
        ];
        // 2.3. UPSERT LOGIC
        // Find if ID already exists in the sheet
        var rowIndex = findRowIndexById(sheet, data.id);
        if (data.action === "delete") {
          if (rowIndex > 0) {
            sheet.deleteRow(rowIndex);
          }
        } else {
          // Create or Update
          if (rowIndex > 0) {
            // UPDATE: Overwrite existing row
            sheet.getRange(rowIndex, 1, 1, rowContent.length).setValues([rowContent]);
          } else {
            // INSERT: Append new row
            sheet.appendRow(rowContent);
          }
        }
        output.processed++;
      } catch (innerErr) {
        // Log individual transaction error but continue processing others
        logError(logSheet, "Transaction Error (" + (data.id || "unknown") + "): " + innerErr.toString());
        output.errors.push({ id: data.id, error: innerErr.toString() });
      }
    }
    return ContentService.createTextOutput(JSON.stringify({ status: "success", result: output }))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (e) {
    logError(logSheet, "Global Error: " + e.toString());
    return ContentService.createTextOutput(JSON.stringify({ status: "error", message: e.toString() }))
      .setMimeType(ContentService.MimeType.JSON);
  } finally {
    lock.releaseLock();
  }
}
// --- HELPERS ---
function ensureLogSheet(ss) {
  var sheet = ss.getSheetByName("_SystemLogs");
  if (!sheet) {
    sheet = ss.insertSheet("_SystemLogs");
    sheet.appendRow(["Timestamp", "Message"]);
  }
  return sheet;
}
function logError(sheet, message) {
  if (sheet) {
    sheet.appendRow([new Date(), message]);
  }
}
// Helper: Normalize Transaction Type
function normalizeType(type, amount) {
  var t = (type || "").toString().toLowerCase();
  // Map 'Debt' (Lending) to 'Out' (Money leaving your pocket)
  if (["debt", "expense", "out", "payment", "lending"].indexOf(t) > -1) return "Out";
  // Map 'Repayment' (Collecting debt) to 'In' (Money coming back)
  if (["repayment", "income", "in", "receive"].indexOf(t) > -1) return "In";
  
  // Fallback based on sign (Negative amount usually means money leaving in some contexts, 
  // but here we rely on the caller's intent. If caller sent negative for Credit, it might be 'In' for Debt Account context)
  // Let's stick to the explicit types first.
  return amount < 0 ? "Out" : "In"; 
}
// Helper: Find Row Index by Transaction ID (Column 10)
// Returns row number (1-based) or -1 if not found
function findRowIndexById(sheet, id) {
  var lastRow = sheet.getLastRow();
  if (lastRow < 2) return -1; // Only header exists
  // Get all IDs from Column J (Index 10)
  // getRange(row, col, numRows, numCols)
  var idColumn = sheet.getRange(2, 10, lastRow - 1, 1).getValues(); 
  
  for (var i = 0; i < idColumn.length; i++) {
    // idColumn[i][0] because getValues returns 2D array
    if (idColumn[i][0] == id) {
      return i + 2; // +2 because: i starts at 0, data starts at row 2
    }
  }
  return -1;
}